<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC é€£æ¥è¨ºæ–·å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        
        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
        }
        
        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }
        
        .section h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: white;
            border-radius: 5px;
        }
        
        .status-label {
            font-weight: 600;
            color: #555;
        }
        
        .status-value {
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
        }
        
        .status-ok {
            background: #10b981;
            color: white;
        }
        
        .status-error {
            background: #ef4444;
            color: white;
        }
        
        .status-warning {
            background: #f59e0b;
            color: white;
        }
        
        .status-info {
            background: #3b82f6;
            color: white;
        }
        
        .log-container {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 5px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
        }
        
        .log-entry {
            margin: 3px 0;
            padding: 3px;
        }
        
        .log-info { color: #4fc3f7; }
        .log-success { color: #81c784; }
        .log-warning { color: #ffb74d; }
        .log-error { color: #e57373; }
        .log-debug { color: #9e9e9e; }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-primary:hover {
            background: #5568d3;
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #5a6268;
        }
        
        .btn-danger {
            background: #ef4444;
            color: white;
        }
        
        .btn-danger:hover {
            background: #dc2626;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .metric-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
            margin: 10px 0;
        }
        
        .metric-label {
            color: #666;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”¬ WebRTC é€£æ¥è¨ºæ–·å·¥å…·</h1>
        
        <!-- é€£æ¥ç‹€æ…‹ -->
        <div class="section">
            <h2>ğŸ“¡ é€£æ¥ç‹€æ…‹</h2>
            <div class="status-item">
                <span class="status-label">WebSocket ç‹€æ…‹:</span>
                <span class="status-value status-info" id="wsStatus">æœªé€£æ¥</span>
            </div>
            <div class="status-item">
                <span class="status-label">ä¸»æ’­ID:</span>
                <span class="status-value status-info" id="broadcasterId">-</span>
            </div>
            <div class="status-item">
                <span class="status-label">ç›´æ’­ç‹€æ…‹:</span>
                <span class="status-value status-info" id="streamStatus">æœªé–‹å§‹</span>
            </div>
            <div class="status-item">
                <span class="status-label">æœ¬åœ°åª’é«”æµ:</span>
                <span class="status-value status-info" id="localStreamStatus">æœªç²å–</span>
            </div>
        </div>
        
        <!-- çµ±è¨ˆæ•¸æ“š -->
        <div class="section">
            <h2>ğŸ“Š é€£æ¥çµ±è¨ˆ</h2>
            <div class="metrics">
                <div class="metric-card">
                    <div class="metric-label">åœ¨ç·šè§€çœ¾</div>
                    <div class="metric-value" id="viewerCount">0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">PeerConnection æ•¸</div>
                    <div class="metric-value" id="peerCount">0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">å·²ç™¼é€ Offer</div>
                    <div class="metric-value" id="offerCount">0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">ICE å€™é¸</div>
                    <div class="metric-value" id="iceCount">0</div>
                </div>
            </div>
        </div>
        
        <!-- æ“ä½œæŒ‰éˆ• -->
        <div class="section">
            <h2>ğŸ® æ§åˆ¶å°</h2>
            <div class="button-group">
                <button class="btn-primary" onclick="testConnection()">æ¸¬è©¦é€£æ¥</button>
                <button class="btn-primary" onclick="simulateStreamStart()">æ¨¡æ“¬é–‹å§‹ç›´æ’­</button>
                <button class="btn-primary" onclick="checkGlobalVariables()">æª¢æŸ¥å…¨å±€è®Šé‡</button>
                <button class="btn-secondary" onclick="clearLogs()">æ¸…é™¤æ—¥èªŒ</button>
                <button class="btn-danger" onclick="resetAll()">é‡ç½®æ‰€æœ‰</button>
            </div>
        </div>
        
        <!-- æ—¥èªŒè¼¸å‡º -->
        <div class="section">
            <h2>ğŸ“ è¨ºæ–·æ—¥èªŒ</h2>
            <div class="log-container" id="logContainer"></div>
        </div>
    </div>
    
    <script>
        let ws = null;
        let diagnosticData = {
            viewerCount: 0,
            peerCount: 0,
            offerCount: 0,
            iceCount: 0
        };
        
        // æ—¥èªŒå‡½æ•¸
        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        function clearLogs() {
            document.getElementById('logContainer').innerHTML = '';
            log('æ—¥èªŒå·²æ¸…é™¤', 'info');
        }
        
        // æ›´æ–°ç‹€æ…‹é¡¯ç¤º
        function updateStatus(elementId, value, statusClass = 'status-info') {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = value;
                element.className = `status-value ${statusClass}`;
            }
        }
        
        function updateMetric(metricId, value) {
            const element = document.getElementById(metricId);
            if (element) {
                element.textContent = value;
            }
        }
        
        // æ¸¬è©¦é€£æ¥
        function testConnection() {
            log('é–‹å§‹æ¸¬è©¦é€£æ¥...', 'info');
            
            // æª¢æŸ¥ WebSocket
            if (!window.streamingSocket) {
                log('âŒ window.streamingSocket ä¸å­˜åœ¨', 'error');
                updateStatus('wsStatus', 'æœªåˆå§‹åŒ–', 'status-error');
            } else {
                const states = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
                const state = states[window.streamingSocket.readyState];
                log(`WebSocket ç‹€æ…‹: ${state}`, window.streamingSocket.readyState === 1 ? 'success' : 'warning');
                updateStatus('wsStatus', state, window.streamingSocket.readyState === 1 ? 'status-ok' : 'status-warning');
            }
            
            // æª¢æŸ¥ä¸»æ’­ID
            if (typeof getBroadcasterId === 'function') {
                const broadcasterId = getBroadcasterId();
                log(`ä¸»æ’­ID: ${broadcasterId}`, 'success');
                updateStatus('broadcasterId', broadcasterId, 'status-ok');
            } else {
                log('âŒ getBroadcasterId å‡½æ•¸ä¸å­˜åœ¨', 'error');
                updateStatus('broadcasterId', 'éŒ¯èª¤', 'status-error');
            }
            
            // æª¢æŸ¥ç›´æ’­ç‹€æ…‹
            if (typeof window.isStreaming !== 'undefined') {
                log(`ç›´æ’­ç‹€æ…‹: ${window.isStreaming ? 'é€²è¡Œä¸­' : 'æœªé–‹å§‹'}`, window.isStreaming ? 'success' : 'info');
                updateStatus('streamStatus', window.isStreaming ? 'é€²è¡Œä¸­' : 'æœªé–‹å§‹', window.isStreaming ? 'status-ok' : 'status-info');
            } else {
                log('âš ï¸ window.isStreaming æœªå®šç¾©', 'warning');
                updateStatus('streamStatus', 'æœªçŸ¥', 'status-warning');
            }
            
            // æª¢æŸ¥æœ¬åœ°åª’é«”æµ
            if (window.localStream) {
                const tracks = window.localStream.getTracks();
                const videoTracks = window.localStream.getVideoTracks();
                const audioTracks = window.localStream.getAudioTracks();
                log(`âœ… æœ¬åœ°åª’é«”æµå­˜åœ¨: ${videoTracks.length} è¦–è¨Š, ${audioTracks.length} éŸ³è¨Š`, 'success');
                updateStatus('localStreamStatus', `${videoTracks.length}V+${audioTracks.length}A`, 'status-ok');
            } else {
                log('âŒ æœ¬åœ°åª’é«”æµä¸å­˜åœ¨', 'error');
                updateStatus('localStreamStatus', 'ä¸å­˜åœ¨', 'status-error');
            }
            
            // æª¢æŸ¥ PeerConnections
            if (window.peerConnections) {
                const count = window.peerConnections.size;
                log(`PeerConnection æ•¸é‡: ${count}`, count > 0 ? 'success' : 'info');
                updateMetric('peerCount', count);
                diagnosticData.peerCount = count;
            } else {
                log('âš ï¸ window.peerConnections ä¸å­˜åœ¨', 'warning');
            }
            
            log('é€£æ¥æ¸¬è©¦å®Œæˆ', 'success');
        }
        
        // æ¨¡æ“¬é–‹å§‹ç›´æ’­
        function simulateStreamStart() {
            log('é–‹å§‹æ¨¡æ“¬ç›´æ’­æµç¨‹...', 'info');
            
            if (!window.streamingSocket || window.streamingSocket.readyState !== 1) {
                log('âŒ WebSocket æœªé€£æ¥ï¼Œç„¡æ³•æ¨¡æ“¬', 'error');
                return;
            }
            
            if (!window.isStreaming) {
                log('âŒ è«‹å…ˆåœ¨ä¸»é é¢é–‹å§‹ç›´æ’­', 'error');
                return;
            }
            
            if (!window.localStream) {
                log('âŒ æœ¬åœ°åª’é«”æµä¸å­˜åœ¨', 'error');
                return;
            }
            
            // ç›£è½ WebSocket æ¶ˆæ¯
            const originalOnMessage = window.streamingSocket.onmessage;
            window.streamingSocket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                log(`ğŸ“¨ æ”¶åˆ°æ¶ˆæ¯: ${data.type}`, 'info');
                
                if (data.type === 'online_viewers') {
                    log(`ğŸ¯ æ”¶åˆ°åœ¨ç·šè§€çœ¾åˆ—è¡¨: ${data.viewers ? data.viewers.length : 0} å€‹`, 'success');
                    diagnosticData.viewerCount = data.viewers ? data.viewers.length : 0;
                    updateMetric('viewerCount', diagnosticData.viewerCount);
                    
                    // æª¢æŸ¥æ˜¯å¦æœƒè§¸ç™¼ handleOnlineViewers
                    if (typeof window.handleOnlineViewers === 'function') {
                        log('âœ… handleOnlineViewers å‡½æ•¸å­˜åœ¨', 'success');
                    } else {
                        log('âŒ handleOnlineViewers å‡½æ•¸ä¸å­˜åœ¨', 'error');
                    }
                }
                
                if (data.type === 'offer') {
                    diagnosticData.offerCount++;
                    updateMetric('offerCount', diagnosticData.offerCount);
                    log(`ğŸ“¤ ç™¼é€ Offer çµ¦è§€çœ¾`, 'success');
                }
                
                // èª¿ç”¨åŸå§‹è™•ç†å‡½æ•¸
                if (originalOnMessage) {
                    originalOnMessage.call(window.streamingSocket, event);
                }
            };
            
            log('âœ… å·²è¨­ç½®æ¶ˆæ¯ç›£è½å™¨', 'success');
            log('è«‹åœ¨ä¸»é é¢è§€å¯Ÿæ§åˆ¶å°è¼¸å‡º', 'info');
        }
        
        // æª¢æŸ¥å…¨å±€è®Šé‡
        function checkGlobalVariables() {
            log('æª¢æŸ¥å…¨å±€è®Šé‡...', 'info');
            
            const variables = [
                'streamingSocket',
                'isStreaming',
                'localStream',
                'peerConnections',
                'getBroadcasterId',
                'handleOnlineViewers',
                'createPeerConnection',
                'sendStreamToViewer'
            ];
            
            variables.forEach(varName => {
                const exists = typeof window[varName] !== 'undefined';
                const type = typeof window[varName];
                log(`${varName}: ${exists ? 'âœ… å­˜åœ¨' : 'âŒ ä¸å­˜åœ¨'} (${type})`, exists ? 'success' : 'error');
            });
            
            log('å…¨å±€è®Šé‡æª¢æŸ¥å®Œæˆ', 'success');
        }
        
        // é‡ç½®æ‰€æœ‰
        function resetAll() {
            diagnosticData = {
                viewerCount: 0,
                peerCount: 0,
                offerCount: 0,
                iceCount: 0
            };
            
            updateMetric('viewerCount', 0);
            updateMetric('peerCount', 0);
            updateMetric('offerCount', 0);
            updateMetric('iceCount', 0);
            
            clearLogs();
            log('å·²é‡ç½®æ‰€æœ‰æ•¸æ“š', 'info');
        }
        
        // é é¢åŠ è¼‰æ™‚åˆå§‹åŒ–
        window.addEventListener('load', function() {
            log('WebRTC è¨ºæ–·å·¥å…·å·²å•Ÿå‹•', 'success');
            log('è«‹åœ¨å¦ä¸€å€‹åˆ†é é–‹å•Ÿä¸»æ’­é é¢é€²è¡Œæ¸¬è©¦', 'info');
            testConnection();
        });
        
        // å®šæœŸæ›´æ–°ç‹€æ…‹
        setInterval(function() {
            if (window.streamingSocket) {
                const states = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
                const state = states[window.streamingSocket.readyState];
                updateStatus('wsStatus', state, window.streamingSocket.readyState === 1 ? 'status-ok' : 'status-warning');
            }
            
            if (typeof window.isStreaming !== 'undefined') {
                updateStatus('streamStatus', window.isStreaming ? 'é€²è¡Œä¸­' : 'æœªé–‹å§‹', window.isStreaming ? 'status-ok' : 'status-info');
            }
            
            if (window.localStream) {
                const videoTracks = window.localStream.getVideoTracks();
                const audioTracks = window.localStream.getAudioTracks();
                updateStatus('localStreamStatus', `${videoTracks.length}V+${audioTracks.length}A`, 'status-ok');
            }
            
            if (window.peerConnections) {
                updateMetric('peerCount', window.peerConnections.size);
            }
        }, 1000);
    </script>
</body>
</html>
