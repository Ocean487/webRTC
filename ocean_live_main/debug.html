<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VibeLo WebRTC è¨ºæ–·å·¥å…·</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; }
        .panel { background: white; padding: 20px; margin: 10px 0; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .panel h3 { margin: 0 0 15px 0; color: #333; }
        .log { background: #000; color: #0f0; padding: 15px; border-radius: 4px; height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px; }
        .controls { margin: 10px 0; }
        button { padding: 10px 20px; margin: 5px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; }
        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-warning { background: #ffc107; color: black; }
        .status { padding: 8px; border-radius: 4px; margin: 5px 0; }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status.warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        .status.info { background: #d1ecf1; color: #0c5460; border: 1px solid #b8daff; }
        #localVideo, #remoteVideo { width: 300px; height: 225px; background: #000; border: 1px solid #ccc; }
        .video-container { display: flex; gap: 20px; }
        .video-panel { text-align: center; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”§ VibeLo WebRTC è¨ºæ–·å·¥å…·</h1>
        
        <div class="panel">
            <h3>ğŸ“¡ WebSocket é€£æ¥ç‹€æ…‹</h3>
            <div id="wsStatus" class="status info">æœªé€£æ¥</div>
            <div class="controls">
                <button class="btn-primary" onclick="connectWebSocket()">é€£æ¥ WebSocket</button>
                <button class="btn-danger" onclick="disconnectWebSocket()">æ–·é–‹é€£æ¥</button>
            </div>
        </div>

        <div class="panel">
            <h3>ğŸ“¹ åª’é«”è¨­å‚™æ¸¬è©¦</h3>
            <div id="mediaStatus" class="status info">æœªæ¸¬è©¦</div>
            <div class="controls">
                <button class="btn-success" onclick="testMediaDevices()">æ¸¬è©¦æ”å½±æ©Ÿå’Œéº¥å…‹é¢¨</button>
                <button class="btn-danger" onclick="stopMediaTest()">åœæ­¢æ¸¬è©¦</button>
            </div>
            <div class="video-container">
                <div class="video-panel">
                    <h4>æœ¬åœ°è¦–é » (ä¸»æ’­ç«¯)</h4>
                    <video id="localVideo" autoplay muted></video>
                </div>
                <div class="video-panel">
                    <h4>é ç«¯è¦–é » (è§€çœ¾ç«¯)</h4>
                    <video id="remoteVideo" autoplay></video>
                </div>
            </div>
        </div>

        <div class="panel">
            <h3>ğŸ”— WebRTC é€£æ¥æ¸¬è©¦</h3>
            <div id="rtcStatus" class="status info">æœªé€£æ¥</div>
            <div class="controls">
                <button class="btn-primary" onclick="startBroadcaster()">å•Ÿå‹•ä¸»æ’­æ¨¡å¼</button>
                <button class="btn-warning" onclick="startViewer()">å•Ÿå‹•è§€çœ¾æ¨¡å¼</button>
                <button class="btn-danger" onclick="stopRTC()">åœæ­¢ WebRTC</button>
            </div>
        </div>

        <div class="panel">
            <h3>ğŸ“‹ è¨ºæ–·æ—¥å¿—</h3>
            <div class="controls">
                <button class="btn-warning" onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
                <button class="btn-primary" onclick="exportLog()">å°å‡ºæ—¥å¿—</button>
            </div>
            <div id="debugLog" class="log"></div>
        </div>
    </div>

    <script>
        let socket = null;
        let localStream = null;
        let peerConnection = null;
        let isConnected = false;
        let mode = null; // 'broadcaster' or 'viewer'

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logDiv = document.getElementById('debugLog');
            const colorMap = {
                info: '#0f0',
                error: '#f00',
                warning: '#ff0',
                success: '#0f0'
            };
            logDiv.innerHTML += `<div style="color: ${colorMap[type] || '#0f0'}">[${timestamp}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[DEBUG] ${message}`);
        }

        function updateStatus(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.className = `status ${type}`;
            element.textContent = message;
        }

        function connectWebSocket() {
            try {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}`;
                
                log(`æ­£åœ¨é€£æ¥åˆ°: ${wsUrl}`, 'info');
                socket = new WebSocket(wsUrl);
                
                socket.onopen = function() {
                    isConnected = true;
                    log('âœ… WebSocket é€£æ¥æˆåŠŸ', 'success');
                    updateStatus('wsStatus', 'å·²é€£æ¥', 'success');
                };
                
                socket.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    log(`ğŸ“¨ æ”¶åˆ°æ¶ˆæ¯: ${data.type}`, 'info');
                    handleWebSocketMessage(data);
                };
                
                socket.onclose = function() {
                    isConnected = false;
                    log('âŒ WebSocket é€£æ¥é—œé–‰', 'error');
                    updateStatus('wsStatus', 'å·²æ–·é–‹', 'error');
                };
                
                socket.onerror = function(error) {
                    log(`âŒ WebSocket éŒ¯èª¤: ${error}`, 'error');
                    updateStatus('wsStatus', 'é€£æ¥éŒ¯èª¤', 'error');
                };
                
            } catch (error) {
                log(`âŒ ç„¡æ³•å»ºç«‹ WebSocket é€£æ¥: ${error}`, 'error');
                updateStatus('wsStatus', 'é€£æ¥å¤±æ•—', 'error');
            }
        }

        function disconnectWebSocket() {
            if (socket) {
                socket.close();
                socket = null;
            }
        }

        async function testMediaDevices() {
            try {
                log('ğŸ¥ æ­£åœ¨è«‹æ±‚æ”å½±æ©Ÿå’Œéº¥å…‹é¢¨æ¬Šé™...', 'info');
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 1280, height: 720 },
                    audio: true
                });
                
                localStream = stream;
                document.getElementById('localVideo').srcObject = stream;
                
                log('âœ… åª’é«”è¨­å‚™ç²å–æˆåŠŸ', 'success');
                log(`ğŸ“¹ è¦–é »è»Œé“: ${stream.getVideoTracks().length}`, 'info');
                log(`ğŸ¤ éŸ³é »è»Œé“: ${stream.getAudioTracks().length}`, 'info');
                
                updateStatus('mediaStatus', 'åª’é«”è¨­å‚™æ­£å¸¸', 'success');
                
            } catch (error) {
                log(`âŒ ç„¡æ³•ç²å–åª’é«”è¨­å‚™: ${error}`, 'error');
                updateStatus('mediaStatus', 'åª’é«”è¨­å‚™éŒ¯èª¤', 'error');
            }
        }

        function stopMediaTest() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                document.getElementById('localVideo').srcObject = null;
                log('ğŸ›‘ åª’é«”è¨­å‚™å·²åœæ­¢', 'info');
                updateStatus('mediaStatus', 'å·²åœæ­¢', 'warning');
            }
        }

        function startBroadcaster() {
            if (!isConnected) {
                log('âŒ è«‹å…ˆé€£æ¥ WebSocket', 'error');
                return;
            }
            
            mode = 'broadcaster';
            log('ğŸ“¡ å•Ÿå‹•ä¸»æ’­æ¨¡å¼...', 'info');
            
            // ç™¼é€ä¸»æ’­åŠ å…¥æ¶ˆæ¯
            const message = {
                type: 'broadcaster_join',
                broadcasterId: 'broadcaster_1',
                userInfo: { username: 'debug_broadcaster', displayName: 'èª¿è©¦ä¸»æ’­' }
            };
            
            socket.send(JSON.stringify(message));
            log('ğŸ“¤ å·²ç™¼é€ä¸»æ’­åŠ å…¥æ¶ˆæ¯', 'info');
            
            updateStatus('rtcStatus', 'ä¸»æ’­æ¨¡å¼ - ç­‰å¾…è§€çœ¾', 'info');
        }

        function startViewer() {
            if (!isConnected) {
                log('âŒ è«‹å…ˆé€£æ¥ WebSocket', 'error');
                return;
            }
            
            mode = 'viewer';
            const viewerId = 'viewer_debug_' + Math.random().toString(36).substring(7);
            
            log('ğŸ‘¥ å•Ÿå‹•è§€çœ¾æ¨¡å¼...', 'info');
            
            // ç™¼é€è§€çœ¾åŠ å…¥æ¶ˆæ¯
            const message = {
                type: 'viewer_join',
                viewerId: viewerId,
                userInfo: { displayName: 'èª¿è©¦è§€çœ¾' }
            };
            
            socket.send(JSON.stringify(message));
            log('ğŸ“¤ å·²ç™¼é€è§€çœ¾åŠ å…¥æ¶ˆæ¯', 'info');
            
            updateStatus('rtcStatus', 'è§€çœ¾æ¨¡å¼ - ç­‰å¾…ä¸»æ’­', 'info');
        }

        function handleWebSocketMessage(data) {
            switch (data.type) {
                case 'online_viewers':
                    log(`ğŸ“º æ”¶åˆ°åœ¨ç·šè§€çœ¾åˆ—è¡¨: ${data.viewers.length} å€‹`, 'success');
                    if (mode === 'broadcaster' && data.viewers.length > 0) {
                        // ä¸»æ’­æ”¶åˆ°è§€çœ¾åˆ—è¡¨ï¼Œé–‹å§‹å»ºç«‹ WebRTC é€£æ¥
                        startWebRTCConnection(data.viewers[0]);
                    }
                    break;
                    
                case 'viewer_join':
                    log(`ğŸ‘¥ æ–°è§€çœ¾åŠ å…¥: ${data.viewerId}`, 'info');
                    if (mode === 'broadcaster') {
                        startWebRTCConnection(data.viewerId);
                    }
                    break;
                    
                case 'offer':
                    log('ğŸ“¨ æ”¶åˆ° WebRTC Offer', 'success');
                    handleOffer(data);
                    break;
                    
                case 'answer':
                    log('ğŸ“¨ æ”¶åˆ° WebRTC Answer', 'success');
                    handleAnswer(data);
                    break;
                    
                case 'ice_candidate':
                    log('ğŸ“¨ æ”¶åˆ° ICE Candidate', 'info');
                    handleIceCandidate(data);
                    break;
                    
                default:
                    log(`ğŸ“¨ å…¶ä»–æ¶ˆæ¯: ${data.type}`, 'info');
            }
        }

        async function startWebRTCConnection(viewerId) {
            try {
                log(`ğŸ”— ç‚ºè§€çœ¾ ${viewerId} å»ºç«‹ WebRTC é€£æ¥...`, 'info');
                
                peerConnection = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });
                
                // æ·»åŠ æœ¬åœ°åª’é«”æµ
                if (localStream) {
                    localStream.getTracks().forEach(track => {
                        peerConnection.addTrack(track, localStream);
                        log(`ğŸ“ å·²æ·»åŠ è»Œé“: ${track.kind}`, 'info');
                    });
                }
                
                // è™•ç† ICE å€™é¸
                peerConnection.onicecandidate = function(event) {
                    if (event.candidate) {
                        log('ğŸ“¤ ç™¼é€ ICE Candidate', 'info');
                        socket.send(JSON.stringify({
                            type: 'ice_candidate',
                            candidate: event.candidate,
                            broadcasterId: 'broadcaster_1',
                            viewerId: viewerId
                        }));
                    }
                };
                
                // å‰µå»º Offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                log('ğŸ“¤ ç™¼é€ WebRTC Offer', 'success');
                socket.send(JSON.stringify({
                    type: 'offer',
                    offer: offer,
                    broadcasterId: 'broadcaster_1',
                    viewerId: viewerId
                }));
                
                updateStatus('rtcStatus', 'å·²ç™¼é€ Offer - ç­‰å¾…å›æ‡‰', 'warning');
                
            } catch (error) {
                log(`âŒ WebRTC é€£æ¥å¤±æ•—: ${error}`, 'error');
                updateStatus('rtcStatus', 'WebRTC é€£æ¥å¤±æ•—', 'error');
            }
        }

        async function handleOffer(data) {
            try {
                log('ğŸ”— è™•ç† WebRTC Offer...', 'info');
                
                peerConnection = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });
                
                // è™•ç†é ç«¯åª’é«”æµ
                peerConnection.ontrack = function(event) {
                    log('ğŸ“º æ”¶åˆ°é ç«¯åª’é«”æµ', 'success');
                    document.getElementById('remoteVideo').srcObject = event.streams[0];
                    updateStatus('rtcStatus', 'æ­£åœ¨æ’­æ”¾é ç«¯è¦–é »', 'success');
                };
                
                // è™•ç† ICE å€™é¸
                peerConnection.onicecandidate = function(event) {
                    if (event.candidate) {
                        log('ğŸ“¤ ç™¼é€ ICE Candidate', 'info');
                        socket.send(JSON.stringify({
                            type: 'ice_candidate',
                            candidate: event.candidate,
                            viewerId: 'viewer_debug'
                        }));
                    }
                };
                
                await peerConnection.setRemoteDescription(data.offer);
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                log('ğŸ“¤ ç™¼é€ WebRTC Answer', 'success');
                socket.send(JSON.stringify({
                    type: 'answer',
                    answer: answer,
                    viewerId: 'viewer_debug'
                }));
                
            } catch (error) {
                log(`âŒ è™•ç† Offer å¤±æ•—: ${error}`, 'error');
            }
        }

        async function handleAnswer(data) {
            try {
                await peerConnection.setRemoteDescription(data.answer);
                log('âœ… WebRTC é€£æ¥å»ºç«‹æˆåŠŸ', 'success');
                updateStatus('rtcStatus', 'WebRTC é€£æ¥æˆåŠŸ', 'success');
            } catch (error) {
                log(`âŒ è™•ç† Answer å¤±æ•—: ${error}`, 'error');
            }
        }

        async function handleIceCandidate(data) {
            try {
                await peerConnection.addIceCandidate(data.candidate);
                log('âœ… ICE Candidate å·²æ·»åŠ ', 'info');
            } catch (error) {
                log(`âŒ æ·»åŠ  ICE Candidate å¤±æ•—: ${error}`, 'error');
            }
        }

        function stopRTC() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            document.getElementById('remoteVideo').srcObject = null;
            mode = null;
            
            log('ğŸ›‘ WebRTC é€£æ¥å·²åœæ­¢', 'info');
            updateStatus('rtcStatus', 'å·²åœæ­¢', 'warning');
        }

        function clearLog() {
            document.getElementById('debugLog').innerHTML = '';
        }

        function exportLog() {
            const logContent = document.getElementById('debugLog').textContent;
            const blob = new Blob([logContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `webrtc-debug-${new Date().toISOString().slice(0, 19)}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // é é¢è¼‰å…¥æ™‚è‡ªå‹•é€£æ¥
        window.addEventListener('load', function() {
            log('ğŸš€ è¨ºæ–·å·¥å…·å·²è¼‰å…¥', 'success');
            log('ğŸ“‹ ä½¿ç”¨èªªæ˜:', 'info');
            log('1. é»æ“Šã€Œé€£æ¥ WebSocketã€å»ºç«‹æœå‹™å™¨é€£æ¥', 'info');
            log('2. é»æ“Šã€Œæ¸¬è©¦æ”å½±æ©Ÿå’Œéº¥å…‹é¢¨ã€ç²å–åª’é«”æ¬Šé™', 'info');
            log('3. é»æ“Šã€Œå•Ÿå‹•ä¸»æ’­æ¨¡å¼ã€æˆ–ã€Œå•Ÿå‹•è§€çœ¾æ¨¡å¼ã€æ¸¬è©¦ WebRTC', 'info');
        });
    </script>
</body>
</html>